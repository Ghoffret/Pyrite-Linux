#!/bin/bash

#############################################################################
#                                                                           #
#                        Pyrite Recovery Tools                             #
#                                                                           #
#     System recovery and repair tools for Pyrite Linux                   #
#                                                                           #
#############################################################################

set -euo pipefail

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

confirm() {
    local prompt="$1"
    local default="${2:-n}"
    local response
    
    if [[ "$default" == "y" ]]; then
        read -r -p "$prompt [Y/n]: " response
        response=${response:-y}
    else
        read -r -p "$prompt [y/N]: " response
        response=${response:-n}
    fi
    
    [[ "$response" =~ ^[Yy]$ ]]
}

check_filesystem() {
    print_info "Checking filesystem integrity..."
    
    local root_device
    root_device=$(findmnt -n -o SOURCE /)
    
    print_info "Root filesystem: $root_device"
    
    if findmnt -n -o FSTYPE / | grep -q "btrfs"; then
        print_info "Running Btrfs scrub on root filesystem..."
        if btrfs scrub start -B /; then
            print_success "Btrfs scrub completed successfully"
        else
            print_error "Btrfs scrub failed"
        fi
        
        print_info "Btrfs filesystem usage:"
        btrfs filesystem usage /
    else
        print_warning "Root filesystem is not Btrfs"
        
        print_info "Running fsck on root filesystem..."
        print_warning "This will be performed on next reboot"
        touch /forcefsck
    fi
}

repair_bootloader() {
    print_info "Attempting to repair bootloader..."
    
    if [[ ! -d /sys/firmware/efi/efivars ]]; then
        print_error "System is not booted in UEFI mode"
        return 1
    fi
    
    if [[ ! -d /boot/loader ]]; then
        print_warning "systemd-boot not found, attempting to reinstall..."
        
        if bootctl install; then
            print_success "systemd-boot installed successfully"
        else
            print_error "Failed to install systemd-boot"
            return 1
        fi
    fi
    
    print_info "Updating bootloader configuration..."
    if bootctl update; then
        print_success "Bootloader updated successfully"
    else
        print_warning "Bootloader update failed"
    fi
    
    print_info "Boot entries:"
    bootctl list
}

repair_initramfs() {
    print_info "Regenerating initramfs..."
    
    local kernel_version
    kernel_version=$(uname -r)
    
    print_info "Current kernel: $kernel_version"
    
    if mkinitcpio -p linux; then
        print_success "Initramfs regenerated successfully"
    else
        print_error "Failed to regenerate initramfs"
        return 1
    fi
}

repair_grub() {
    print_info "GRUB repair (alternative bootloader)..."
    
    if ! command -v grub-install &>/dev/null; then
        print_error "GRUB not installed"
        return 1
    fi
    
    local boot_disk
    boot_disk=$(lsblk -no PKNAME "$(findmnt -n -o SOURCE /boot)")
    
    print_info "Installing GRUB to /dev/$boot_disk"
    
    if grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB; then
        print_success "GRUB installed successfully"
        
        print_info "Updating GRUB configuration..."
        if grub-mkconfig -o /boot/grub/grub.cfg; then
            print_success "GRUB configuration updated"
        else
            print_warning "GRUB configuration update failed"
        fi
    else
        print_error "GRUB installation failed"
        return 1
    fi
}

recover_from_snapshot() {
    print_info "Snapshot recovery options:"
    
    if [[ ! -d /.snapshots ]]; then
        print_error "No snapshots directory found"
        return 1
    fi
    
    print_info "Available snapshots:"
    ls -la /.snapshots/
    
    echo
    read -r -p "Enter snapshot name to recover from: " snapshot_name
    
    if [[ -z "$snapshot_name" ]]; then
        print_error "No snapshot name provided"
        return 1
    fi
    
    local snapshot_path="/.snapshots/$snapshot_name"
    if [[ ! -d "$snapshot_path" ]]; then
        print_error "Snapshot not found: $snapshot_path"
        return 1
    fi
    
    print_warning "This operation requires manual intervention and system reboot"
    print_info "Recovery steps:"
    echo "1. Boot from live USB/ISO"
    echo "2. Mount the Btrfs filesystem"
    echo "3. Backup current @ subvolume: mv /mnt/@ /mnt/@.broken"
    echo "4. Create new @ from snapshot: btrfs subvolume snapshot $snapshot_path /mnt/@"
    echo "5. Reboot into recovered system"
    
    print_warning "Automatic snapshot recovery not implemented yet"
}

reset_network() {
    print_info "Resetting network configuration..."
    
    # Restart NetworkManager
    if systemctl restart NetworkManager; then
        print_success "NetworkManager restarted"
    else
        print_error "Failed to restart NetworkManager"
    fi
    
    # Reset DNS
    if systemctl restart systemd-resolved; then
        print_success "DNS resolver restarted"
    else
        print_warning "Failed to restart DNS resolver"
    fi
    
    # Flush DNS cache
    if command -v resolvectl &>/dev/null; then
        resolvectl flush-caches
        print_success "DNS cache flushed"
    fi
    
    print_info "Network interfaces:"
    ip link show
}

fix_permissions() {
    print_info "Fixing common permission issues..."
    
    # Fix /tmp permissions
    chmod 1777 /tmp
    print_success "Fixed /tmp permissions"
    
    # Fix sudo permissions
    if [[ -f /etc/sudoers.d/wheel ]]; then
        chmod 440 /etc/sudoers.d/wheel
        print_success "Fixed sudo permissions"
    fi
    
    # Fix SSH permissions
    if [[ -d /etc/ssh ]]; then
        chmod 700 /etc/ssh
        chmod 600 /etc/ssh/ssh_host_*_key 2>/dev/null || true
        chmod 644 /etc/ssh/ssh_host_*_key.pub 2>/dev/null || true
        print_success "Fixed SSH permissions"
    fi
    
    # Fix home directory permissions
    for home_dir in /home/*; do
        if [[ -d "$home_dir" ]]; then
            local username
            username=$(basename "$home_dir")
            if getent passwd "$username" &>/dev/null; then
                chown -R "$username:$username" "$home_dir"
                chmod 755 "$home_dir"
                print_success "Fixed permissions for $home_dir"
            fi
        fi
    done
}

emergency_shell() {
    print_info "Starting emergency shell..."
    print_warning "You are now in an emergency shell"
    print_info "Common recovery commands:"
    echo "  - journalctl -xb     # Check boot logs"
    echo "  - systemctl status   # Check service status"
    echo "  - mount -o remount,rw /  # Remount root as read-write"
    echo "  - fsck /dev/sdXN     # Check filesystem"
    echo "  - exit               # Exit emergency shell"
    echo
    
    bash --norc --noprofile
}

system_rescue_menu() {
    while true; do
        echo -e "${BLUE}"
        echo "████████████████████████████████████████████████████████████████"
        echo "██                                                            ██"
        echo "██                  Pyrite Recovery Tools                     ██"
        echo "██                                                            ██"
        echo "████████████████████████████████████████████████████████████████"
        echo -e "${NC}"
        echo
        
        echo "Recovery Options:"
        echo "================"
        echo
        echo "1) Check filesystem integrity"
        echo "2) Repair bootloader (systemd-boot)"
        echo "3) Repair bootloader (GRUB)"
        echo "4) Regenerate initramfs"
        echo "5) Recover from snapshot"
        echo "6) Reset network configuration"
        echo "7) Fix file permissions"
        echo "8) Emergency shell"
        echo "9) Exit"
        echo
        
        read -r -p "Select option [1-9]: " choice
        
        case "$choice" in
            1)
                check_filesystem
                ;;
            2)
                repair_bootloader
                ;;
            3)
                repair_grub
                ;;
            4)
                repair_initramfs
                ;;
            5)
                recover_from_snapshot
                ;;
            6)
                reset_network
                ;;
            7)
                fix_permissions
                ;;
            8)
                emergency_shell
                ;;
            9)
                print_info "Exiting Pyrite Recovery Tools"
                exit 0
                ;;
            *)
                print_warning "Invalid selection"
                ;;
        esac
        
        echo
        read -r -p "Press Enter to continue..."
        clear
    done
}

show_help() {
    echo "Pyrite Recovery Tools - System recovery and repair utilities"
    echo
    echo "Usage: pyrite-recovery [COMMAND]"
    echo
    echo "Commands:"
    echo "  fscheck               Check filesystem integrity"
    echo "  bootloader            Repair bootloader"
    echo "  grub                  Repair GRUB bootloader"
    echo "  initramfs             Regenerate initramfs"
    echo "  snapshot              Recover from snapshot"
    echo "  network               Reset network configuration"
    echo "  permissions           Fix file permissions"
    echo "  shell                 Emergency shell"
    echo
    echo "Options:"
    echo "  -h, --help           Show this help message"
    echo "  -i, --interactive    Launch interactive menu"
    echo
    echo "Examples:"
    echo "  pyrite-recovery fscheck"
    echo "  pyrite-recovery bootloader"
    echo "  pyrite-recovery --interactive"
}

main() {
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        -i|--interactive|"")
            system_rescue_menu
            ;;
        fscheck)
            check_filesystem
            ;;
        bootloader)
            repair_bootloader
            ;;
        grub)
            repair_grub
            ;;
        initramfs)
            repair_initramfs
            ;;
        snapshot)
            recover_from_snapshot
            ;;
        network)
            reset_network
            ;;
        permissions)
            fix_permissions
            ;;
        shell)
            emergency_shell
            ;;
        *)
            print_error "Unknown command: $1"
            show_help
            exit 1
            ;;
    esac
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi